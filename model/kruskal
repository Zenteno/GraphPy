def kruskal(self):
		dim = self.__matrix.get_dim()
		kruskal = self.__kruskal_algorithm()
		dim = len(kruskal)
		for i in range(dim):
			roads = self.__breadthfirst_search(matrix, i)
			path = []
			for j in range(dim):
				path.append( self.__get_path(roads, j) )
			longer = 0
			length = -1
			for j in range(dim):
				if len(path[j]) == dim:
					# retorna el primer camino de longitud = dim
					return path[j]
		return None

def __kruskal_algorithm(self):
	# revisar que pasa si hay bidireccion entre a y b, y el grafo es dirigido
	matrix = self.get_matrix()
	dim = self.__matrix.get_dim()
	kruskalMatrix = []
	for i in range(dim):
		kruskalMatrix.append([])
		for j in range(dim):
			kruskalMatrix[i].append(0)
	alreadyTraveled = []

	while len(alreadyTraveled) != dim and :
		# Obtener la arista menor en 'smaller'
		smaller = 0
		row = -1
		col = -1
		for i in range(dim):
			for j in range(dim):
				if matrix[i][j] != 0:
					if smaller == 0:
						row = i
						col = j
						smaller = matrix[i][j]
					elif smaller > matrix[i][j]:
						row = i
						col = j
						smaller = matrix[i][j]
		if smaller == 0:
			return None
		
		if self.directed():
			matrix[row][col] = 0
		else:
			matrix[row][col] = 0
			matrix[col][row] = 0
		
		# revisa los nodos adyacentes a la arista 'smaller'
		adjacent = 0
		for i in range( len(alreadyTraveled) ):
			if alreadyTraveled[i] == row:
				adjacent += 1
			if alreadyTraveled[i] == col:
				adjacent += 2
		
		if adjacent == 0 or adjacent == 2:
			alreadyTraveled.append(row)
		if adjacent == 0 or adjacent == 1:
			alreadyTraveled.append(col)
		
		if adjacent == 3:
			if self.__connected_matrix(kruskalMatrix):
				continue
		
		if self.directed():
			kruskalMatrix[row][col] = smaller
		else:
			kruskalMatrix[row][col] = smaller
			kruskalMatrix[col][row] = smaller
		
		if adjacent == 3 and not self.__connected_matrix(matrix):
			if self.directed():
				kruskalMatrix[row][col] = 0
			else:
				kruskalMatrix[row][col] = 0
				kruskalMatrix[col][row] = 0
	return kruskalMatrix
